/*
ESES Extension

  ESES Defines a way to encode arbitrary HTML into the restricted CMS-API format while maintaining readability for non ESES aware clients to the extent possible.

  The extension builds on having a `<p style="display: none;">` tag containing ESES mapping data, this one maps element-hiarchy-keys to the elements extended data.
  This is since the CMS API format only allows:
    HTML Elements:
      - p
      - h3
      - div
      - img (with only property "src")
    
    p/h3 CSS Style Properties:
      - font-size
      - color
      - display
      - font-family
      - font-weight
      - font-style
      - text-decoration
      - text-transform

    div CSS Style Properties:
      - width
      - height
      - display
      - background-color
      - flex-flow
      - align-items
      - justify-content
      - border
      - border-radius
      - margin
      - margin-top
      - margin-bottom
      - margin-left
      - margin-right
      - padding
      - padding-top
      - padding-bottom
      - padding-left
      - padding-right
      - background-image

    And div is the only element who can have child elements, p and h3 must only have text content.

  The goal of ESES is to map additional HTML element types, their properties (except img src), content for non text elements aswell as any CSS properties not supported by the CMS format.
    This means if an element is of a type not supported we can represent it as a div, p or h3 then map that element's hiarchy key to the original element type and its properties.
    Elements properties and css-properties that are supported by the CMS format should be kept inside the html however any non supported properties should be stored in the ESES mapping data.

    The ESES mapping data must be html+ini safe text and is thus stored as base64 incoded JSON. With the prefix "ESES1:" (for v1 of the ESES extension)
      since the mapping element has `display: none` we hint to other clients that this is not meant to be displayed.
      
      The JSON structure is: 
        {
            "<hiarchy-key>": {
                "element": "<original-element-type>",
                "attributes": {
                    "<attribute-name>": "<attribute-value>",
                    ...
                },
                "styles": {
                    "<css-property-name>": "<css-property-value>",
                    ...
                },
                "content": "<non-text-content>",
                "isWrapper": <true|false>
            },
            ...
        }

      But fields `element`, `attributes`, `styles` and `content` are omitted if they are not relevant to that element. `isWrapper` is only present and true if the element was only added because its parent had to be converted to a div to hold children and this wraps the content, this element can thus be replaced with its own text-content.

    HTML elements can be categorized into one of the following five categories:
      1. Headers - h1, h2, h4, h5, h6 - Mapped to `h3`
      2. Text - Al elements that are primarily text-based, ex semantics like `em` or formatters like `b` and `i`. - Mapped to `p`
      3. Containers - Elements semantic or layouting that contain other elements, ex `main` or `span` - Mapped to `div`
      4. Represented - Elements who are not supported but can have thier core properties represented as text for non ESES clients, ex `video` who can be represented as `[Video: <source>]` - Mapped to `p`
      5. NotRepresented - Elements that have no relevant representation outside of ESES, ex `script`, self closing elements or non-content elements are also in this category like `br`, stored fully in ESES.

    Since we want to maintain readability for non ESES clients we try to map elements to the first three categories when possible, otherwise we try to the "represented" category before falling back to "not represented".
      Example `<b>bold text</b>` becomes `<p>bold text</p>` with mapping data saying that this hiarchy key is a `b` element.
      And `<figure><img src="image.jpg"><figcaption>Caption</figcaption></figure>` becomes `<div><img src="image.jpg"><p>Caption</p></div>` with mapping data saying that the hiarchy key of the div is a `figure` element and the hiarchy key of the p is a `figcaption` element.
      But some elements make more sense to be represented with their content, ex `<video><source src="video.mp4"></video>` becomes `<p>[Video: video.mp4]</p>` combining the <source> element into the representation.

    But since the API only supports child elements under `div` elements any children under non-container elements will have thier parent converted into a div.
      Example `<h2>Header <em>with emphasis</em></h2>` becomes `<div><h3>Header </h3><p>with emphasis</p></div>` with mapping data saying that the hiarchy key of the div is an `h2` element and the hiarchy key of the p is an `em` element and the hiarchy key of the h3 has "isWrapper" true meaning the h3 can be reduced to their text-content when back-converting.
      Example `<h2>Header start <em> with emphasis</em> and end</h2>` becomes `<div><h3>Header start </h3><p> with emphasis</p><h3> and end</h3></div>` with mapping data saying that the hiarchy key of the div is an `h2` element, the hiarchy key of the p is an `em` element and both h3 hiarchy keys have "isWrapper" true meaning they can be reduced to their text-content when back-converting.

    When back-converting we use the mapping data to restore the original elements, completely, recursing over and handling "isWrapper" elements by replacing them with their text-content, and restoring attributes, styles and content as needed, aswell as the element type ofcourse.

    When converting we can use recursion and the bellow elementsMap, if an element type is under "header" and has no child elements we map it to `h3`, if its under "text" and has no child elements we map it to `p`, if its under "container" we map it to `div`,
      if it has content and is udner "header" or "text" we handle with the "isWrapper" logic.
    If its under emulated we use the provided function to get its text representation.
    All other elements are mapped to NotRepresented.

    Example WonkyHTML with ESES data:
    <div style="width:100%;height:650px;display:flex;background-color:#d6d6d6;flex-flow:column;justify-content:space-around;padding-bottom:25px;">
        <p style="display: none;">ESES1:...base64-encode-of-json...</p>
        <h3 style="font-size:36px;color:#005500;">Koalor – Allmänt</h3>
        <p style="font-size:18px;color:#003300;">Koalor är små tåliga trädlevande djur från Australien.</p>
        <img style="width:100%;height:250px;height:250;border-radius:10;border-radius:10;display:block;" src="https://upload.wikimedia.org/wikipedia/commons/4/49/Koala_climbing_tree.jpg" alt="Image">
        <div style="width:80%;height:300px;display:flex;background-color:#a3d9a5;flex-flow:row;">
            <h3 style="font-size:28px;color:#006633;">Fakta om Koalor</h3>
            <p style="font-size:16px;color:#666600;">De är kända för att äta eukalyptusblad.</p>
            <p style="font-size:18px;color:#ff6600;">Koalor äter nästan uteslutande eukalyptusblad.</p>
            <img style="width:80%;height:200px;height:200;border-radius:15;border-radius:15;display:block;" src="https://upload.wikimedia.org/wikipedia/commons/e/e9/Koala_eating_eucalyptus_leaf.jpg" alt="Image">
        </div>
        <div style="width:80%;height:250px;display:flex;background-color:#ffe4b5;flex-flow:column;">
            <h3 style="font-size:24px;color:green;">Roliga fakta</h3>
            <p style="font-size:16px;color:#005500;">Koalor sover upp till 20 timmar per dag.</p>
            <p style="font-size:14px;">Koalor har starka klor för att klättra i träd.</p>
            <p style="">Koalor kommunicerar med olika ljud, från snarkningar till skrik.</p>
            <p style="">test</p>
            <img style="width:90%;height:180px;height:180;border-radius:20;border-radius:20;display:block;" src="https://upload.wikimedia.org/wikipedia/commons/0/08/Koala_sleeping_in_tree.jpg" alt="Image">
            <img style="width:70%;height:140px;height:140;border-radius:25;border-radius:25;display:block;" src="https://upload.wikimedia.org/wikipedia/commons/1/14/Koala_close_up.jpg" alt="Image">
        </div>
    </div>
*/

class ESESApiExtender {
    constructor(api) {
        this.api = api;
        this.esesVersion = "1";

        this.elementsMap = {
            "header": [
                "h1", "h2", "h4", "h5", "h6"
            ],
            "text": [
                "p", "span", "em", "strong", "b", "i", "u", "small", "mark", "sub", "sup"
            ],
            "container": [
                "div", "main", "section", "article", "header", "footer", "aside", "nav"
            ],
            "emulated": [
                ["video", (el) => { 
                    const sources = el.getElementsByTagName("source"); 
                    if (sources.length > 0) { 
                        const srcEl = sources[0]; 
                        if (srcEl.hasAttribute("src")) { 
                            return `[Video: ${srcEl.getAttribute("src")}]`; 
                        } 
                    } 
                    return "[Video]"; 
                }],
                ["audio", (el) => { 
                    const sources = el.getElementsByTagName("source"); 
                    if (sources.length > 0) { 
                        const srcEl = sources[0]; 
                        if (srcEl.hasAttribute("src")) { 
                            return `[Audio: ${srcEl.getAttribute("src")}]`; 
                        } 
                    } 
                    return "[Audio]"; 
                }],
            ]
            // All other elements are fallbacked to NotRepresented
        }
    }

    esesJsonToMetaString(jsonobj) {
        // Takes jsonobj => jsonstr => base64str => "ESES{v}:" + base64str
        const jsonstr = JSON.stringify(jsonobj);
        const base64str = btoa(unescape(encodeURIComponent(jsonstr))); // UTF-8 safe
        return "ESES" + this.esesVersion + ":" + base64str;
    }

    metaStringToEsesJson(metastr) {
        // Takes "ESES{v}:" + base64str => base64str => jsonstr => jsonobj
        const esesPrefix = "ESES" + this.esesVersion + ":";
        if (!metastr.startsWith(esesPrefix)) {
            throw new Error("Invalid ESES meta string");
        }

        const base64str = metastr.slice(esesPrefix.length);
        const jsonstr = decodeURIComponent(escape(atob(base64str))); // UTF-8 safe
        return JSON.parse(jsonstr);
    }

    /**
     * Converts CMS-restricted HTML back to full HTML using ESES mapping data
     * @param {string} html - The CMS-restricted HTML with ESES mapping
     * @returns {string} - The restored full HTML
     */
    FromFullHtml(html) {
        const parser = new DOMParser();
        const doc = parser.parseFromString(html, 'text/html');
        
        // Find and extract ESES mapping data
        const esesElement = doc.querySelector('p[style*="display: none"]');
        let mappingData = {};
        
        if (esesElement && esesElement.textContent.startsWith('ESES')) {
            try {
                mappingData = this.metaStringToEsesJson(esesElement.textContent);
                esesElement.remove(); // Remove the mapping element
            } catch (e) {
                console.warn('Failed to parse ESES mapping data:', e);
            }
        }
        
        // Always process documentElement, but check if it contains a body element
        const bodyElement = doc.querySelector('body');
        if (bodyElement) {
            // If there's a body element in the HTML, process its children
            this.processElementFromFullHtml(bodyElement, mappingData, '');
            return `<body>${bodyElement.innerHTML}</body>`;
        } else {
            // If no body element, process the documentElement children
            this.processElementFromFullHtml(doc.documentElement, mappingData, '');
            return doc.documentElement.innerHTML;
        }
    }

    /**
     * Converts full HTML to CMS-restricted format with ESES mapping
     * @param {string} html - The full HTML to convert
     * @returns {string} - The CMS-restricted HTML with ESES mapping
     */
    ToLesserHtml(html) {
        const parser = new DOMParser();
        const doc = parser.parseFromString(html, 'text/html');
        
        const mappingData = {};
        const hierarchyKey = '0';
        
        // Always process documentElement, but check if it contains a body element
        const bodyElement = doc.querySelector('body');
        if (bodyElement) {
            // If there's a body element in the HTML, process its children
            this.processElementToFullHtml(bodyElement, mappingData, hierarchyKey);
            
            // Add ESES mapping element if there's mapping data
            if (Object.keys(mappingData).length > 0) {
                const esesElement = doc.createElement('p');
                esesElement.style.display = 'none';
                esesElement.textContent = this.esesJsonToMetaString(mappingData);
                
                if (bodyElement.firstChild) {
                    bodyElement.insertBefore(esesElement, bodyElement.firstChild);
                } else {
                    bodyElement.appendChild(esesElement);
                }
            }
            
            return bodyElement.innerHTML;
        } else {
            // If no body element, process the documentElement children
            this.processElementToFullHtml(doc.documentElement, mappingData, hierarchyKey);
            
            // Add ESES mapping element if there's mapping data
            if (Object.keys(mappingData).length > 0) {
                const esesElement = doc.createElement('p');
                esesElement.style.display = 'none';
                esesElement.textContent = this.esesJsonToMetaString(mappingData);
                
                if (doc.documentElement.firstChild) {
                    doc.documentElement.insertBefore(esesElement, doc.documentElement.firstChild);
                } else {
                    doc.documentElement.appendChild(esesElement);
                }
            }
            
            return doc.documentElement.innerHTML;
        }
    }

    /**
     * Recursively processes elements when converting from full HTML
     * @param {Element} element - The element to process
     * @param {Object} mappingData - The ESES mapping data
     * @param {string} hierarchyKey - The hierarchy key for this element
     */
    processElementFromFullHtml(element, mappingData, hierarchyKey) {
        const mapping = mappingData[hierarchyKey];
        
        if (mapping) {
            // Restore original element type
            if (mapping.element && mapping.element !== element.tagName.toLowerCase()) {
                const newElement = document.createElement(mapping.element);
                
                // Copy all child nodes
                while (element.firstChild) {
                    newElement.appendChild(element.firstChild);
                }
                
                // Restore attributes
                if (mapping.attributes) {
                    for (const [name, value] of Object.entries(mapping.attributes)) {
                        newElement.setAttribute(name, value);
                    }
                }
                
                // Restore styles
                if (mapping.styles) {
                    for (const [property, value] of Object.entries(mapping.styles)) {
                        newElement.style.setProperty(property, value);
                    }
                }
                
                // Replace the element
                element.parentNode.replaceChild(newElement, element);
                element = newElement;
            }
            
            // Handle isWrapper elements by replacing with text content
            if (mapping.isWrapper) {
                const textContent = element.textContent;
                const textNode = document.createTextNode(textContent);
                element.parentNode.replaceChild(textNode, element);
                return;
            }
            
            // Restore content for non-text elements
            if (mapping.content) {
                element.innerHTML = mapping.content;
            }
        }
        
        // Process children recursively
        const children = Array.from(element.children);
        children.forEach((child, index) => {
            const childHierarchyKey = hierarchyKey ? `${hierarchyKey}.${index}` : `${index}`;
            this.processElementFromFullHtml(child, mappingData, childHierarchyKey);
        });
    }

    /**
     * Recursively processes elements when converting to full HTML
     * @param {Element} element - The element to process
     * @param {Object} mappingData - The ESES mapping data to build
     * @param {string} hierarchyKey - The hierarchy key for this element
     */
    processElementToFullHtml(element, mappingData, hierarchyKey) {
        const tagName = element.tagName.toLowerCase();
        const category = this.getElementCategory(tagName);
        
        let newElement = element;
        let needsMapping = false;
        let mapping = {};
        
        // Handle elements with children that need to be containers first
        const hasChildren = element.children.length > 0;
        if (hasChildren && (category === 'header' || category === 'text')) {
            // Convert to div and wrap text content
            const wrapperDiv = document.createElement('div');
            const textParts = this.splitTextAndElements(element);
            
            textParts.forEach((part, index) => {
                if (typeof part === 'string') {
                    const wrapperElement = document.createElement(category === 'header' ? 'h3' : 'p');
                    wrapperElement.textContent = part;
                    const childKey = `${hierarchyKey}.${index}`;
                    mappingData[childKey] = { isWrapper: true };
                    wrapperDiv.appendChild(wrapperElement);
                } else {
                    wrapperDiv.appendChild(part);
                }
            });
            
            newElement = wrapperDiv;
            needsMapping = true;
            mapping.element = tagName;
        } else {
            // Determine if element needs mapping
            if (category === 'header' && tagName !== 'h3') {
                needsMapping = true;
                mapping.element = tagName;
                newElement = document.createElement('h3');
            } else if (category === 'text' && tagName !== 'p') {
                needsMapping = true;
                mapping.element = tagName;
                newElement = document.createElement('p');
            } else if (category === 'container' && tagName !== 'div') {
                needsMapping = true;
                mapping.element = tagName;
                newElement = document.createElement('div');
            } else if (category === 'emulated') {
                needsMapping = true;
                mapping.element = tagName;
                const representation = this.getEmulatedRepresentation(element);
                newElement = document.createElement('p');
                newElement.textContent = representation;
            } else if (category === 'not-represented') {
                needsMapping = true;
                mapping.element = tagName;
                mapping.content = element.innerHTML;
                newElement = document.createElement('p');
                newElement.textContent = `[${tagName.toUpperCase()}]`;
            }
        }
        
        // Copy attributes and filter supported ones
        if (needsMapping) {
            const supportedAttrs = this.getSupportedAttributes(newElement.tagName.toLowerCase());
            const supportedStyles = this.getSupportedStyles(newElement.tagName.toLowerCase());
            
            // Copy supported attributes
            Array.from(element.attributes).forEach(attr => {
                if (supportedAttrs.includes(attr.name)) {
                    newElement.setAttribute(attr.name, attr.value);
                } else {
                    mapping.attributes = mapping.attributes || {};
                    mapping.attributes[attr.name] = attr.value;
                }
            });
            
            // Copy supported styles
            const computedStyle = window.getComputedStyle(element);
            Array.from(computedStyle).forEach(property => {
                const value = computedStyle.getPropertyValue(property);
                if (supportedStyles.includes(property) && value && value !== 'initial' && value !== 'inherit') {
                    newElement.style.setProperty(property, value);
                } else if (value && value !== 'initial' && value !== 'inherit') {
                    mapping.styles = mapping.styles || {};
                    mapping.styles[property] = value;
                }
            });
            
            // Copy text content if it's a text element and not already handled
            if ((category === 'text' || category === 'header') && !hasChildren) {
                newElement.textContent = element.textContent;
            }
            
            // Store mapping data
            if (Object.keys(mapping).length > 0) {
                mappingData[hierarchyKey] = mapping;
            }
            
            // Replace element
            element.parentNode.replaceChild(newElement, element);
            element = newElement;
        }
        
        // Process children recursively
        const children = Array.from(element.children);
        children.forEach((child, index) => {
            const childHierarchyKey = `${hierarchyKey}.${index}`;
            this.processElementToFullHtml(child, mappingData, childHierarchyKey);
        });
    }

    /**
     * Determines the category of an HTML element
     * @param {string} tagName - The tag name
     * @returns {string} - The category
     */
    getElementCategory(tagName) {
        if (this.elementsMap.header.includes(tagName)) return 'header';
        if (this.elementsMap.text.includes(tagName)) return 'text';
        if (this.elementsMap.container.includes(tagName)) return 'container';
        
        for (const [emulatedTag] of this.elementsMap.emulated) {
            if (emulatedTag === tagName) return 'emulated';
        }
        
        return 'not-represented';
    }

    /**
     * Gets the text representation for emulated elements
     * @param {Element} element - The element to represent
     * @returns {string} - The text representation
     */
    getEmulatedRepresentation(element) {
        for (const [tagName, representationFn] of this.elementsMap.emulated) {
            if (element.tagName.toLowerCase() === tagName) {
                return representationFn(element);
            }
        }
        return `[${element.tagName.toUpperCase()}]`;
    }

    /**
     * Splits text content and child elements for wrapper handling
     * @param {Element} element - The element to split
     * @returns {Array} - Array of text strings and elements
     */
    splitTextAndElements(element) {
        const parts = [];
        let currentText = '';
        
        for (const node of element.childNodes) {
            if (node.nodeType === Node.TEXT_NODE) {
                currentText += node.textContent;
            } else if (node.nodeType === Node.ELEMENT_NODE) {
                if (currentText) {
                    parts.push(currentText);
                    currentText = '';
                }
                parts.push(node);
            }
        }
        
        if (currentText) {
            parts.push(currentText);
        }
        
        return parts;
    }

    /**
     * Gets supported attributes for a tag
     * @param {string} tagName - The tag name
     * @returns {Array} - Array of supported attribute names
     */
    getSupportedAttributes(tagName) {
        if (tagName === 'img') return ['src'];
        return [];
    }

    /**
     * Gets supported CSS properties for a tag
     * @param {string} tagName - The tag name
     * @returns {Array} - Array of supported CSS property names
     */
    getSupportedStyles(tagName) {
        if (tagName === 'p' || tagName === 'h3') {
            return [
                'font-size', 'color', 'display', 'font-family', 'font-weight',
                'font-style', 'text-decoration', 'text-transform'
            ];
        } else if (tagName === 'div') {
            return [
                'width', 'height', 'display', 'background-color', 'flex-flow',
                'align-items', 'justify-content', 'border', 'border-radius',
                'margin', 'margin-top', 'margin-bottom', 'margin-left', 'margin-right',
                'padding', 'padding-top', 'padding-bottom', 'padding-left', 'padding-right',
                'background-image'
            ];
        }
        return [];
    }
}

// Test
window.addEventListener('DOMContentLoaded', (event) => {
    // Mock API object for testing
    const mockApi = {};

    const eses = new ESESApiExtender(mockApi);

    const html = `
    <body>
        <main>
            <h2>Header start <em> with emphasis</em> and end</h2>
            <figure>
                <img src="image.jpg">
                <figcaption>Caption</figcaption>
            </figure>
            <video>
                <source src="video.mp4">
            </video>
        </main>
        <aside>
            <h6>Side Header</h6>
            <p>Regular text</p>
            <img src="sideimage.png">
            <img src="sideimage2.png" alt="An image">
        </aside>
    </body>
    `;

    console.log("Original HTML:");
    console.log(html);

    const lesser = eses.ToLesserHtml(html);

    console.log("Lesser HTML:");
    console.log(lesser);

    const restored = eses.FromFullHtml(lesser);

    console.log("Restored HTML:");
    console.log(restored);

    if (html.trim() === restored.trim()) {
        console.log("Success: Restored HTML matches original");
    } else {
        console.log("Failure: Restored HTML does not match original");
        console.log("Differences:");
        console.log("Original length:", html.length);
        console.log("Restored length:", restored.length);
    }
});