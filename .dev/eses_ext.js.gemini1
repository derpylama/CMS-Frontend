/*
ESES Extension

  ESES Defines a way to encode arbitrary HTML into the restricted CMS-API format while maintaining readability for non ESES aware clients to the extent possible.

  The extension builds on having a `<p style="display: none;">` tag containing ESES mapping data, this one maps element-hiarchy-keys to the elements extended data.
  This is since the CMS API format only allows:
    HTML Elements:
      - p
      - h3
      - div
      - img (with only property "src")
    
    p/h3 CSS Style Properties:
      - font-size
      - color
      - display
      - font-family
      - font-weight
      - font-style
      - text-decoration
      - text-transform

    div CSS Style Properties:
      - width
      - height
      - display
      - background-color
      - flex-flow
      - align-items
      - justify-content
      - border
      - border-radius
      - margin
      - margin-top
      - margin-bottom
      - margin-left
      - margin-right
      - padding
      - padding-top
      - padding-bottom
      - padding-left
      - padding-right
      - background-image

    And div is the only element who can have child elements, p and h3 must only have text content.

  The goal of ESES is to map additional HTML element types, their properties (except img src), content for non text elements aswell as any CSS properties not supported by the CMS format.
    This means if an element is of a type not supported we can represent it as a div, p or h3 then map that element's hiarchy key to the original element type and its properties.
    Elements properties and css-properties that are supported by the CMS format should be kept inside the html however any non supported properties should be stored in the ESES mapping data.

    The ESES mapping data must be html+ini safe text and is thus stored as base64 incoded JSON. With the prefix "ESES1:" (for v1 of the ESES extension)
      since the mapping element has `display: none` we hint to other clients that this is not meant to be displayed.
      
      The JSON structure is: 
        {
            "<hiarchy-key>": {
                "element": "<original-element-type>",
                "attributes": {
                    "<attribute-name>": "<attribute-value>",
                    ...
                },
                "styles": {
                    "<css-property-name>": "<css-property-value>",
                    ...
                },
                "content": "<non-text-content>",
                "isWrapper": <true|false>
            },
            ...
        }

      But fields `element`, `attributes`, `styles` and `content` are omitted if they are not relevant to that element. `isWrapper` is only present and true if the element was only added because its parent had to be converted to a div to hold children and this wraps the content, this element can thus be replaced with its own text-content.

    HTML elements can be categorized into one of the following five categories:
      1. Headers - h1, h2, h4, h5, h6 - Mapped to `h3`
      2. Text - Al elements that are primarily text-based, ex semantics like `em` or formatters like `b` and `i`. - Mapped to `p`
      3. Containers - Elements semantic or layouting that contain other elements, ex `main` or `span` - Mapped to `div`
      4. Represented - Elements who are not supported but can have thier core properties represented as text for non ESES clients, ex `video` who can be represented as `[Video: <source>]` - Mapped to `p`
      5. NotRepresented - Elements that have no relevant representation outside of ESES, ex `script`, self closing elements or non-content elements are also in this category like `br`, stored fully in ESES.

    Since we want to maintain readability for non ESES clients we try to map elements to the first three categories when possible, otherwise we try to the "represented" category before falling back to "not represented".
      Example `<b>bold text</b>` becomes `<p>bold text</p>` with mapping data saying that this hiarchy key is a `b` element.
      And `<figure><img src="image.jpg"><figcaption>Caption</figcaption></figure>` becomes `<div><img src="image.jpg"><p>Caption</p></div>` with mapping data saying that the hiarchy key of the div is a `figure` element and the hiarchy key of the p is a `figcaption` element.
      But some elements make more sense to be represented with their content, ex `<video><source src="video.mp4"></video>` becomes `<p>[Video: video.mp4]</p>` combining the <source> element into the representation.

    But since the API only supports child elements under `div` elements any children under non-container elements will have thier parent converted into a div.
      Example `<h2>Header <em>with emphasis</em></h2>` becomes `<div><h3>Header </h3><p>with emphasis</p></div>` with mapping data saying that the hiarchy key of the div is an `h2` element and the hiarchy key of the p is an `em` element and the hiarchy key of the h3 has "isWrapper" true meaning the h3 can be reduced to their text-content when back-converting.
      Example `<h2>Header start <em> with emphasis</em> and end</h2>` becomes `<div><h3>Header start </h3><p> with emphasis</p><h3> and end</h3></div>` with mapping data saying that the hiarchy key of the div is an `h2` element, the hiarchy key of the p is an `em` element and both h3 hiarchy keys have "isWrapper" true meaning they can be reduced to their text-content when back-converting.

    When back-converting we use the mapping data to restore the original elements, completely, recursing over and handling "isWrapper" elements by replacing them with their text-content, and restoring attributes, styles and content as needed, aswell as the element type ofcourse.

    When converting we can use recursion and the bellow elementsMap, if an element type is under "header" and has no child elements we map it to `h3`, if its under "text" and has no child elements we map it to `p`, if its under "container" we map it to `div`,
      if it has content and is udner "header" or "text" we handle with the "isWrapper" logic.
    If its under emulated we use the provided function to get its text representation.
    All other elements are mapped to NotRepresented.

    Example WonkyHTML with ESES data:
    <div style="width:100%;height:650px;display:flex;background-color:#d6d6d6;flex-flow:column;justify-content:space-around;padding-bottom:25px;">
        <p style="display: none;">ESES1:...base64-encode-of-json...</p>
        <h3 style="font-size:36px;color:#005500;">Koalor – Allmänt</h3>
        <p style="font-size:18px;color:#003300;">Koalor är små tåliga trädlevande djur från Australien.</p>
        <img style="width:100%;height:250px;height:250;border-radius:10;border-radius:10;display:block;" src="https://upload.wikimedia.org/wikipedia/commons/4/49/Koala_climbing_tree.jpg" alt="Image">
        <div style="width:80%;height:300px;display:flex;background-color:#a3d9a5;flex-flow:row;">
            <h3 style="font-size:28px;color:#006633;">Fakta om Koalor</h3>
            <p style="font-size:16px;color:#666600;">De är kända för att äta eukalyptusblad.</p>
            <p style="font-size:18px;color:#ff6600;">Koalor äter nästan uteslutande eukalyptusblad.</p>
            <img style="width:80%;height:200px;height:200;border-radius:15;border-radius:15;display:block;" src="https://upload.wikimedia.org/wikipedia/commons/e/e9/Koala_eating_eucalyptus_leaf.jpg" alt="Image">
        </div>
        <div style="width:80%;height:250px;display:flex;background-color:#ffe4b5;flex-flow:column;">
            <h3 style="font-size:24px;color:green;">Roliga fakta</h3>
            <p style="font-size:16px;color:#005500;">Koalor sover upp till 20 timmar per dag.</p>
            <p style="font-size:14px;">Koalor har starka klor för att klättra i träd.</p>
            <p style="">Koalor kommunicerar med olika ljud, från snarkningar till skrik.</p>
            <p style="">test</p>
            <img style="width:90%;height:180px;height:180;border-radius:20;border-radius:20;display:block;" src="https://upload.wikimedia.org/wikipedia/commons/0/08/Koala_sleeping_in_tree.jpg" alt="Image">
            <img style="width:70%;height:140px;height:140;border-radius:25;border-radius:25;display:block;" src="https://upload.wikimedia.org/wikipedia/commons/1/14/Koala_close_up.jpg" alt="Image">
        </div>
    </div>
*/

class ESESApiExtender {
    constructor(api) {
        this.api = api;
        this.esesVersion = "1";
        this.esesMeta = {};
        this.currentHiarchyKey = 0;

        this.cmsSupportedPStyles = [
            "font-size", "color", "display", "font-family", "font-weight",
            "font-style", "text-decoration", "text-transform"
        ];
        this.cmsSupportedDivStyles = [
            "width", "height", "display", "background-color", "flex-flow",
            "align-items", "justify-content", "border", "border-radius", "margin",
            "margin-top", "margin-bottom", "margin-left", "margin-right", "padding",
            "padding-top", "padding-bottom", "padding-left", "padding-right",
            "background-image"
        ];
        this.cmsSupportedImgAttrs = ["src"];

        this.elementsMap = {
            "header": [
                "h1", "h2", "h4", "h5", "h6"
            ],
            "text": [
                "p", "span", "em", "strong", "b", "i", "u", "small", "mark", "sub", "sup"
            ],
            "container": [
                "div", "main", "section", "article", "header", "footer", "aside", "nav",
                "figure", "figcaption"
            ],
            "emulated": [
                ["video", (el) => {
                    const sourceEl = el.querySelector("source");
                    if (sourceEl && sourceEl.hasAttribute("src")) {
                        return `[Video: ${sourceEl.getAttribute("src")}]`;
                    }
                    return "[Video]";
                }],
                ["audio", (el) => {
                    const sourceEl = el.querySelector("source");
                    if (sourceEl && sourceEl.hasAttribute("src")) {
                        return `[Audio: ${sourceEl.getAttribute("src")}]`;
                    }
                    return "[Audio]";
                }],
            ]
            // All other elements are fallbacked to NotRepresented
        };
    }

    esesJsonToMetaString(jsonobj) {
        const jsonstr = JSON.stringify(jsonobj);
        const base64str = btoa(jsonstr); // Use btoa for browser environments
        return "ESES" + this.esesVersion + ":" + base64str;
    }

    metaStringToEsesJson(metastr) {
        const esesPrefix = "ESES" + this.esesVersion + ":";
        if (!metastr.startsWith(esesPrefix)) {
            throw new Error("Invalid ESES meta string");
        }

        const base64str = metastr.slice(esesPrefix.length);
        const jsonstr = atob(base64str); // Use atob for browser environments
        return JSON.parse(jsonstr);
    }

    _getHiarchyKey() {
        return `eses-key-${this.currentHiarchyKey++}`;
    }

    _isCmsSupportedStyle(tagName, styleName) {
        if (tagName === "p" || tagName === "h3") {
            return this.cmsSupportedPStyles.includes(styleName);
        } else if (tagName === "div") {
            return this.cmsSupportedDivStyles.includes(styleName);
        }
        return false;
    }

    _processNodeToLesser(node, parentHiarchyKey = null) {
        if (node.nodeType === Node.TEXT_NODE) {
            return document.createTextNode(node.nodeValue);
        }
        if (node.nodeType !== Node.ELEMENT_NODE) {
            return null;
        }

        const originalTagName = node.tagName.toLowerCase();
        let targetTagName = originalTagName;
        let esesEntry = {};
        const hiarchyKey = this._getHiarchyKey();

        // Convert NodeList to Array to use .some()
        const childNodesArray = Array.from(node.childNodes);

        // Check for content beyond simple text for non-container elements
        const hasElementChildren = childNodesArray.some(
            (child) => child.nodeType === Node.ELEMENT_NODE,
        );
        const hasMixedContent = childNodesArray.some(
            (child) =>
                child.nodeType === Node.ELEMENT_NODE ||
                (child.nodeType === Node.TEXT_NODE &&
                    child.nodeValue.trim().length > 0 &&
                    child.previousSibling &&
                    child.previousSibling.nodeType === Node.ELEMENT_NODE),
        );

        let needsWrapper = false;
        let originalContent = node.innerHTML;

        if (this.elementsMap.header.includes(originalTagName)) {
            if (hasElementChildren || hasMixedContent) {
                targetTagName = "div";
                esesEntry.element = originalTagName;
                needsWrapper = true;
            } else {
                targetTagName = "h3";
                if (originalTagName !== "h3") {
                    esesEntry.element = originalTagName;
                }
            }
        } else if (this.elementsMap.text.includes(originalTagName)) {
            if (hasElementChildren || hasMixedContent) {
                targetTagName = "div";
                esesEntry.element = originalTagName;
                needsWrapper = true;
            } else {
                targetTagName = "p";
                if (originalTagName !== "p") {
                    esesEntry.element = originalTagName;
                }
            }
        } else if (this.elementsMap.container.includes(originalTagName)) {
            targetTagName = "div";
            if (originalTagName !== "div") {
                esesEntry.element = originalTagName;
            }
        } else {
            // Emulated or NotRepresented
            const emulatedEntry = this.elementsMap.emulated.find(
                (e) => e[0] === originalTagName,
            );
            if (emulatedEntry) {
                targetTagName = "p";
                esesEntry.element = originalTagName;
                esesEntry.content = originalContent; // Store original content
                node.textContent = emulatedEntry[1](node); // Set emulated text
            } else {
                targetTagName = "p"; // Fallback to p for non-represented
                esesEntry.element = originalTagName;
                esesEntry.content = originalContent;
                node.textContent = ""; // Clear content for non-represented elements
            }
        }

        const newElement = document.createElement(targetTagName);

        // Process attributes
        for (const attr of Array.from(node.attributes)) { // Ensure attributes is also an array if iterating
            if (originalTagName === "img" && attr.name === "src") {
                newElement.setAttribute(attr.name, attr.value);
            } else {
                if (!esesEntry.attributes) esesEntry.attributes = {};
                esesEntry.attributes[attr.name] = attr.value;
            }
        }

        // Process styles
        const originalStyles = node.style;
        for (let i = 0; i < originalStyles.length; i++) {
            const styleName = originalStyles[i];
            const styleValue = originalStyles.getPropertyValue(styleName);

            if (this._isCmsSupportedStyle(targetTagName, styleName)) {
                newElement.style.setProperty(styleName, styleValue);
            } else {
                if (!esesEntry.styles) esesEntry.styles = {};
                esesEntry.styles[styleName] = styleValue;
            }
        }

        if (Object.keys(esesEntry).length > 0) {
            this.esesMeta[hiarchyKey] = esesEntry;
        }

        if (needsWrapper) {
            let tempWrapper = document.createElement(targetTagName);
            if (Object.keys(esesEntry).length > 0) {
                this.esesMeta[hiarchyKey] = esesEntry; // Ensure parent data is stored
            }

            let lastWrapperChild = null;

            childNodesArray.forEach((child) => { // Use childNodesArray here too
                if (child.nodeType === Node.TEXT_NODE && child.nodeValue.trim().length > 0) {
                    const textNode = document.createElement(
                        this.elementsMap.header.includes(originalTagName) ? "h3" : "p",
                    );
                    textNode.textContent = child.nodeValue;
                    const wrapperKey = this._getHiarchyKey();
                    this.esesMeta[wrapperKey] = { isWrapper: true };
                    textNode.setAttribute("data-eses-key", wrapperKey);
                    tempWrapper.appendChild(textNode);
                    lastWrapperChild = textNode;
                } else if (child.nodeType === Node.ELEMENT_NODE) {
                    const processedChild = this._processNodeToLesser(child);
                    if (processedChild) {
                        tempWrapper.appendChild(processedChild);
                        lastWrapperChild = processedChild;
                    }
                }
            });
            newElement.setAttribute("data-eses-key", hiarchyKey);
            newElement.innerHTML = tempWrapper.innerHTML; // Copy children
        } else if (targetTagName !== "img" && esesEntry.content === undefined) {
            // Only process children if not an img (which is self-closing in CMS)
            // and if content is not already set by emulated types.
            if (targetTagName === "p" || targetTagName === "h3") {
                newElement.textContent = node.textContent;
            } else {
                childNodesArray.forEach((child) => { // Use childNodesArray here too
                    const processedChild = this._processNodeToLesser(child);
                    if (processedChild) {
                        newElement.appendChild(processedChild);
                    }
                });
            }
        }

        newElement.setAttribute("data-eses-key", hiarchyKey);

        return newElement;
    }

    FromFullHtml(html) {
        this.esesMeta = {};
        this.currentHiarchyKey = 0;

        const parser = new DOMParser();
        const doc = parser.parseFromString(html, "text/html");
        let rootElement;

        // Try to find the actual content. DOMParser might wrap things in html/body.
        if (doc.body && doc.body.children.length > 0) {
            if (
                doc.body.children.length === 1 &&
                doc.body.firstChild.tagName.toLowerCase() !== "p" &&
                doc.body.firstChild.tagName.toLowerCase() !== "h3"
            ) {
                rootElement = doc.body.firstChild;
            } else {
                // Create a synthetic div to hold all body children if multiple or p/h3
                rootElement = document.createElement("div");
                while (doc.body.firstChild) {
                    rootElement.appendChild(doc.body.firstChild);
                }
            }
        } else {
            // If body is empty, parse the HTML directly as a fragment
            const tempDiv = document.createElement("div");
            tempDiv.innerHTML = html;
            rootElement = tempDiv;
        }

        const lesserDoc = document.createElement("div"); // Create a container for the result

        const esesMetaElement = rootElement.querySelector(
            'p[style*="display: none;"][data-eses-prefix^="ESES"]',
        );
        if (esesMetaElement) {
            this.esesMeta = this.metaStringToEsesJson(esesMetaElement.textContent);
            esesMetaElement.remove(); // Remove it from the DOM for processing
        }

        Array.from(rootElement.childNodes).forEach((node) => {
            const processedNode = this._processNodeToLesser(node);
            if (processedNode) {
                lesserDoc.appendChild(processedNode);
            }
        });

        // Add the ESES meta data as a hidden paragraph
        if (Object.keys(this.esesMeta).length > 0) {
            const metaP = document.createElement("p");
            metaP.style.display = "none";
            metaP.textContent = this.esesJsonToMetaString(this.esesMeta);
            metaP.setAttribute("data-eses-prefix", "ESES" + this.esesVersion); // Add a marker
            lesserDoc.prepend(metaP);
        }

        return lesserDoc.innerHTML;
    }

    _restoreNodeFromLesser(node) {
        if (node.nodeType === Node.TEXT_NODE) {
            return document.createTextNode(node.nodeValue);
        }
        if (node.nodeType !== Node.ELEMENT_NODE) {
            return null;
        }

        const hiarchyKey = node.getAttribute("data-eses-key");
        const esesData = this.esesMeta[hiarchyKey];

        let originalTagName = node.tagName.toLowerCase();
        let newElement;

        if (esesData) {
            if (esesData.isWrapper) {
                // Replace wrapper with its text content
                return document.createTextNode(node.textContent);
            }
            if (esesData.element) {
                originalTagName = esesData.element;
            }
            newElement = document.createElement(originalTagName);

            // Restore attributes
            if (esesData.attributes) {
                for (const attrName in esesData.attributes) {
                    newElement.setAttribute(attrName, esesData.attributes[attrName]);
                }
            }
            // Copy existing attributes from the lesser node if they exist (e.g., img src)
            for (const attr of node.attributes) {
                if (attr.name !== "data-eses-key" && attr.name !== "style") {
                    newElement.setAttribute(attr.name, attr.value);
                }
            }

            // Restore styles
            if (esesData.styles) {
                for (const styleName in esesData.styles) {
                    newElement.style.setProperty(styleName, esesData.styles[styleName]);
                }
            }
            // Copy existing supported styles from the lesser node
            const existingStyles = node.style;
            for (let i = 0; i < existingStyles.length; i++) {
                const styleName = existingStyles[i];
                const styleValue = existingStyles.getPropertyValue(styleName);
                newElement.style.setProperty(styleName, styleValue);
            }

            // Restore content for emulated/not-represented
            if (esesData.content !== undefined) {
                newElement.innerHTML = esesData.content;
            } else {
                // Recursively restore children
                Array.from(node.childNodes).forEach((child) => {
                    const restoredChild = this._restoreNodeFromLesser(child);
                    if (restoredChild) {
                        newElement.appendChild(restoredChild);
                    }
                });
            }
        } else {
            // If no ESES data, it's a natively supported element without extra data
            newElement = document.createElement(originalTagName);

            // Copy all attributes and styles as they are natively supported
            for (const attr of node.attributes) {
                if (attr.name !== "data-eses-key") {
                    newElement.setAttribute(attr.name, attr.value);
                }
            }
            // Recursively restore children
            Array.from(node.childNodes).forEach((child) => {
                const restoredChild = this._restoreNodeFromLesser(child);
                if (restoredChild) {
                    newElement.appendChild(restoredChild);
                }
            });
        }

        return newElement;
    }

    ToFullHtml(lesserhtml) {
        this.esesMeta = {}; // Reset meta for conversion
        this.currentHiarchyKey = 0;

        const parser = new DOMParser();
        const doc = parser.parseFromString(lesserhtml, "text/html");
        let rootElement;

        // Find the ESES meta data
        const esesMetaElement = doc.querySelector(
            'p[style*="display: none;"][data-eses-prefix^="ESES"]',
        );
        if (esesMetaElement) {
            this.esesMeta = this.metaStringToEsesJson(esesMetaElement.textContent);
            esesMetaElement.remove(); // Remove it from the DOM for processing
        }

        // Get the content to restore
        if (doc.body && doc.body.children.length > 0) {
            rootElement = document.createElement("div"); // Use a synthetic div to hold all children
            while (doc.body.firstChild) {
                rootElement.appendChild(doc.body.firstChild);
            }
        } else {
            // If body is empty, parse the HTML directly as a fragment
            const tempDiv = document.createElement("div");
            tempDiv.innerHTML = lesserhtml;
            rootElement = tempDiv;
        }

        const fullDocFragment = document.createDocumentFragment();

        Array.from(rootElement.childNodes).forEach((node) => {
            const restoredNode = this._restoreNodeFromLesser(node);
            if (restoredNode) {
                fullDocFragment.appendChild(restoredNode);
            }
        });

        // To return a string that might not be wrapped in a single element,
        // we can create a temporary div and get its innerHTML
        const tempContainer = document.createElement("div");
        tempContainer.appendChild(fullDocFragment);
        return tempContainer.innerHTML;
    }
}

// Test
window.addEventListener('DOMContentLoaded', (event) => {
    const eses = new ESESApiExtender({});

    const originalHtml = `
    <body>
        <main style="background-color: lightblue;">
            <h2 style="color: blue;">Header start <em style="font-weight: bold;"> with emphasis</em> and end</h2>
            <figure style="border: 1px solid black;">
                <img src="image.jpg" width="100">
                <figcaption style="font-style: italic;">Caption</figcaption>
            </figure>
            <video controls>
                <source src="video.mp4" type="video/mp4">
                Your browser does not support the video tag.
            </video>
            <br>
            <span style="display: block; margin-top: 10px;">A block span.</span>
        </main>
        <aside style="float: right; width: 30%;">
            <h6 style="text-decoration: underline;">Side Header</h6>
            <p>Regular text</p>
            <img src="sideimage.png">
            <img src="sideimage2.png" alt="An image">
        </aside>
        <script>alert('malicious script');</script>
        <p style="font-size: 16px;">Final paragraph.</p>
    </body>
    `;

    console.log("Original HTML:");
    console.log(originalHtml);

    const lesser = eses.FromFullHtml(originalHtml);

    console.log("\nLesser HTML:");
    console.log(lesser);

    // To compare, we need to normalize the HTML.
    // This is a very basic normalization; a robust solution would use a proper HTML parser.
    const normalizeHtml = (htmlString) => {
        const tempDiv = document.createElement("div");
        tempDiv.innerHTML = htmlString.replace(/\n\s*/g, ""); // Remove newlines and leading spaces
        return tempDiv.innerHTML;
    };

    const restored = eses.ToFullHtml(lesser);

    console.log("\nRestored HTML:");
    console.log(restored);

    const normalizedOriginal = normalizeHtml(originalHtml);
    const normalizedRestored = normalizeHtml(restored);

    if (normalizedOriginal === normalizedRestored) {
        console.log("\nSuccess: Restored HTML matches original (normalized)");
    } else {
        console.log("\nFailure: Restored HTML does not match original (normalized)");
        console.log("Normalized Original:", normalizedOriginal);
        console.log("Normalized Restored:", normalizedRestored);
    }

    // Test a simple case
    const simpleHtml = `<b>bold text</b>`;
    const simpleLesser = eses.FromFullHtml(simpleHtml);
    const simpleRestored = eses.ToFullHtml(simpleLesser);
    console.log("\nSimple Test - Original:", simpleHtml);
    console.log("Simple Test - Lesser:", simpleLesser);
    console.log("Simple Test - Restored:", simpleRestored);
    if (normalizeHtml(simpleHtml) === normalizeHtml(simpleRestored)) {
        console.log("Simple Test: Success");
    } else {
        console.log("Simple Test: Failure");
    }

    // Test a figure with image and figcaption
    const figureHtml = `<figure><img src="image.jpg"><figcaption>Caption</figcaption></figure>`;
    const figureLesser = eses.FromFullHtml(figureHtml);
    const figureRestored = eses.ToFullHtml(figureLesser);
    console.log("\nFigure Test - Original:", figureHtml);
    console.log("Figure Test - Lesser:", figureLesser);
    console.log("Figure Test - Restored:", figureRestored);
    if (normalizeHtml(figureHtml) === normalizeHtml(figureRestored)) {
        console.log("Figure Test: Success");
    } else {
        console.log("Figure Test: Failure");
    }

    // Test a video element
    const videoHtml = `<video><source src="video.mp4"></video>`;
    const videoLesser = eses.FromFullHtml(videoHtml);
    const videoRestored = eses.ToFullHtml(videoLesser);
    console.log("\nVideo Test - Original:", videoHtml);
    console.log("Video Test - Lesser:", videoLesser);
    console.log("Video Test - Restored:", videoRestored);
    if (normalizeHtml(videoHtml) === normalizeHtml(videoRestored)) {
        console.log("Video Test: Success");
    } else {
        console.log("Video Test: Failure");
    }
});