/*
ESES Extension

  ESES Defines a way to encode arbitrary HTML into the restricted CMS-API format while maintaining readability for non ESES aware clients to the extent possible.

  The extension builds on having a `<p style="display: none;">` tag containing ESES mapping data, this one maps element-hiarchy-keys to the elements extended data.
  This is since the CMS API format only allows:
    HTML Elements:
      - p
      - h3
      - div
      - img (with only property "src")

    p/h3 CSS Style Properties:
      - font-size
      - color
      - display
      - font-family
      - font-weight
      - font-style
      - text-decoration
      - text-transform

    div CSS Style Properties:
      - width
      - height
      - display
      - background-color
      - flex-flow
      - align-items
      - justify-content
      - border
      - border-radius
      - margin
      - margin-top
      - margin-bottom
      - margin-left
      - margin-right
      - padding
      - padding-top
      - padding-bottom
      - padding-left
      - padding-right
      - background-image

    And div is the only element who can have child elements, p and h3 must only have text content.

  The goal of ESES is to map additional HTML element types, their properties (except img src), content for non text elements aswell as any CSS properties not supported by the CMS format.
    This means if an element is of a type not supported we can represent it as a div, p or h3 then map that element's hiarchy key to the original element type and its properties.
    Elements properties and css-properties that are supported by the CMS format should be kept inside the html however any non supported properties should be stored in the ESES mapping data.

    The ESES mapping data must be html+ini safe text and is thus stored as base64 incoded JSON. With the prefix "ESES1:" (for v1 of the ESES extension)
      since the mapping element has `display: none` we hint to other clients that this is not meant to be displayed.

      The JSON structure is:
        {
            "<hiarchy-key>": {
                "element": "<original-element-type>",
                "attributes": {
                    "<attribute-name>": "<attribute-value>",
                    ...
                },
                "styles": {
                    "<css-property-name>": "<css-property-value>",
                    ...
                },
                "content": "<non-text-content>",
                "isWrapper": <true|false>
            },
            ...
        }

      But fields `element`, `attributes`, `styles` and `content` are omitted if they are not relevant to that element. `isWrapper` is only present and true if the element was only added because its parent had to be converted to a div to hold children and this wraps the content, this element can thus be replaced with its own text-content.

    HTML elements can be categorized into one of the following five categories:
      1. Headers - h1, h2, h4, h5, h6 - Mapped to `h3`
      2. Text - Al elements that are primarily text-based, ex semantics like `em` or formatters like `b` and `i`. - Mapped to `p`
      3. Containers - Elements semantic or layouting that contain other elements, ex `main` or `span` - Mapped to `div`
      4. Represented - Elements who are not supported but can have thier core properties represented as text for non ESES clients, ex `video` who can be represented as `[Video: <source>]` - Mapped to `p`
      5. NotRepresented - Elements that have no relevant representation outside of ESES, ex `script`, self closing elements or non-content elements are also in this category like `br`, stored fully in ESES.

    Since we want to maintain readability for non ESES clients we try to map elements to the first three categories when possible, otherwise we try to the "represented" category before falling back to "not represented".
      Example `<b>bold text</b>` becomes `<p>bold text</p>` with mapping data saying that this hiarchy key is a `b` element.
      And `<figure><img src="image.jpg"><figcaption>Caption</figcaption></figure>` becomes `<div><img src="image.jpg"><p>Caption</p></div>` with mapping data saying that the hiarchy key of the div is a `figure` element and the hiarchy key of the p is a `figcaption` element.
      But some elements make more sense to be represented with their content, ex `<video><source src="video.mp4"></video>` becomes `<p>[Video: video.mp4]</p>` combining the <source> element into the representation.

    But since the API only supports child elements under `div` elements any children under non-container elements will have thier parent converted into a div.
      Example `<h2>Header <em>with emphasis</em></h2>` becomes `<div><h3>Header </h3><p>with emphasis</p></div>` with mapping data saying that the hiarchy key of the div is an `h2` element and the hiarchy key of the p is an `em` element and the hiarchy key of the h3 has "isWrapper" true meaning the h3 can be reduced to their text-content when back-converting.
      Example `<h2>Header start <em> with emphasis</em> and end</h2>` becomes `<div><h3>Header start </h3><p> with emphasis</p><h3> and end</h3></div>` with mapping data saying that the hiarchy key of the div is an `h2` element, the hiarchy key of the p is an `em` element and both h3 hiarchy keys have "isWrapper" true meaning they can be reduced to their text-content when back-converting.

    When back-converting we use the mapping data to restore the original elements, completely, recursing over and handling "isWrapper" elements by replacing them with their text-content, and restoring attributes, styles and content as needed, aswell as the element type ofcourse.

    When converting we can use recursion and the bellow elementsMap, if an element type is under "header" and has no child elements we map it to `h3`, if its under "text" and has no child elements we map it to `p`, if its under "container" we map it to `div`,
      if it has content and is udner "header" or "text" we handle with the "isWrapper" logic.
    If its under emulated we use the provided function to get its text representation.
    All other elements are mapped to NotRepresented.

    !NOTE! LesserHTML does not allow empty elements, all elements without content will be in the NotRepresented category and only exist in the ESES mapping data.

    !NOTE! LesserHTML does not support divs without any styling so for any divs that have no styling we add `style="display:block;"` to ensure they are valid LesserHTML.

    Example LesserHTML with ESES data:
    <div style="width:100%;height:650px;display:flex;background-color:#d6d6d6;flex-flow:column;justify-content:space-around;padding-bottom:25px;">
        <p style="display: none;">ESES1:...base64-encode-of-json...</p>
        <h3 style="font-size:36px;color:#005500;">Koalor – Allmänt</h3>
        <p style="font-size:18px;color:#003300;">Koalor är små tåliga trädlevande djur från Australien.</p>
        <img style="width:100%;height:250px;height:250;border-radius:10;border-radius:10;display:block;" src="https://upload.wikimedia.org/wikipedia/commons/4/49/Koala_climbing_tree.jpg" alt="Image">
        <div style="width:80%;height:300px;display:flex;background-color:#a3d9a5;flex-flow:row;">
            <h3 style="font-size:28px;color:#006633;">Fakta om Koalor</h3>
            <p style="font-size:16px;color:#666600;">De är kända för att äta eukalyptusblad.</p>
            <p style="font-size:18px;color:#ff6600;">Koalor äter nästan uteslutande eukalyptusblad.</p>
            <img style="width:80%;height:200px;height:200;border-radius:15;border-radius:15;display:block;" src="https://upload.wikimedia.org/wikipedia/commons/e/e9/Koala_eating_eucalyptus_leaf.jpg" alt="Image">
        </div>
        <div style="width:80%;height:250px;display:flex;background-color:#ffe4b5;flex-flow:column;">
            <h3 style="font-size:24px;color:green;">Roliga fakta</h3>
            <p style="font-size:16px;color:#005500;">Koalor sover up to 20 timmar per dag.</p>
            <p style="font-size:14px;">Koalor har starka klor för att klättra in träd.</p>
            <p style="">Koalor kommunicerar med olika ljud, från snarkningar till skrik.</p>
            <p style="">test</p>
            <img style="width:90%;height:180px;height:180;border-radius:20;border-radius:20;display:block;" src="https://upload.wikimedia.org/wikipedia/commons/0/08/Koala_sleeping_in_tree.jpg" alt="Image">
            <img style="width:70%;height:140px;height:140;border-radius:25;border-radius:25;display:block;" src="https://upload.wikimedia.org/wikipedia/commons/1/14/Koala_close_up.jpg" alt="Image">
        </div>
    </div>
*/

// Helper function to convert HTML string to a DOM-like structure
// In a browser environment, this uses DOMParser.
function HTMLtoDOM(htmlString) {
    if (typeof DOMParser !== "undefined") {
      const parser = new DOMParser();
      // Parse as 'text/html' to get a full document, then return body's children within a temp div.
      const doc = parser.parseFromString(htmlString, "text/html");
      const tempDiv = document.createElement('div');
      // Move all children from the parsed body to the tempDiv
      while (doc.body && doc.body.firstChild) {
        tempDiv.appendChild(doc.body.firstChild);
      }
      return tempDiv; // Returns a single root element containing the parsed HTML structure
    } else {
      throw new Error("DOMParser is required for HTMLtoDOM function in a browser environment.");
    }
  }
  
  class ESESApiExtender {
    constructor(api) {
      this.api = api;
      this.esesVersion = "1";
  
      this.elementsMap = {
        header: ["h1", "h2", "h4", "h5", "h6"],
        text: ["p", "span", "em", "strong", "b", "i", "u", "small", "mark", "sub", "sup"],
        // figure, figcaption, ul, ol, li are treated as containers because they often contain other elements
        // and their semantic meaning isn't directly supported by p/h3/img.
        container: ["div", "main", "section", "article", "header", "footer", "aside", "nav", "figure", "figcaption", "ul", "ol", "li"],
        emulated: [
          [
            "video",
            (el) => {
              const sources = el.getElementsByTagName("source");
              if (sources.length > 0 && sources[0].hasAttribute("src")) {
                return `[Video: ${sources[0].getAttribute("src")}]`;
              }
              return "[Video]";
            },
          ],
          [
            "audio",
            (el) => {
              const sources = el.getElementsByTagName("source");
              if (sources.length > 0 && sources[0].hasAttribute("src")) {
                return `[Audio: ${sources[0].getAttribute("src")}]`;
              }
              return "[Audio]";
            },
          ],
          [
            "iframe",
            (el) => {
              if (el.hasAttribute("src")) {
                return `[iframe: ${el.getAttribute("src")}]`;
              }
              return "[iframe]";
            },
          ],
        ],
        // Elements that are not represented in LesserHTML at all, only in ESES data
        notRepresented: [
          "script",
          "style",
          "br",
          "hr",
          "link",
          "meta",
          "input",
          "textarea",
          "button",
          "form",
          "select",
          "option",
          "canvas",
          "svg",
          "table",
          "thead",
          "tbody",
          "tfoot",
          "tr",
          "td",
          "th",
          "head",
          "html",
          "body",
          "title",
          "noscript",
        ],
      };
  
      this.allowedPH3Styles = [
        "font-size",
        "color",
        "display",
        "font-family",
        "font-weight",
        "font-style",
        "text-decoration",
        "text-transform",
      ];
  
      this.allowedDivStyles = [
        "width",
        "height",
        "display",
        "background-color",
        "flex-flow",
        "align-items",
        "justify-content",
        "border",
        "border-radius",
        "margin",
        "margin-top",
        "margin-bottom",
        "margin-left",
        "margin-right",
        "padding",
        "padding-top",
        "padding-bottom",
        "padding-left",
        "padding-right",
        "background-image",
      ];
  
      this.allowedImgAttributes = ["src"];
    }
  
    esesJsonToMetaString(jsonobj) {
      const jsonstr = JSON.stringify(jsonobj);
      const base64str = btoa(jsonstr);
      return "ESES" + this.esesVersion + ":" + base64str;
    }
  
    metaStringToEsesJson(metastr) {
      const esesPrefix = "ESES" + this.esesVersion + ":";
      if (!metastr.startsWith(esesPrefix)) {
        throw new Error("Invalid ESES meta string");
      }
      const base64str = metastr.slice(esesPrefix.length);
      const jsonstr = atob(base64str);
      return JSON.parse(jsonstr);
    }
  
    _extractAllowedStyles(element, lesserTagName) {
      const styleAttr = element.getAttribute("style");
      if (!styleAttr) return { allowed: {}, other: {} };
  
      const styles = {};
      styleAttr.split(";").forEach((s) => {
        const parts = s.split(":").map((p) => p.trim());
        if (parts.length === 2 && parts[0] && parts[1]) {
          styles[parts[0]] = parts[1];
        }
      });
  
      const allowed = {};
      const other = {};
      const allowedList =
        lesserTagName === "div"
          ? this.allowedDivStyles
          : ["p", "h3"].includes(lesserTagName)
            ? this.allowedPH3Styles
            : []; // img has no allowed styles
  
      for (const prop in styles) {
        if (allowedList.includes(prop)) {
          allowed[prop] = styles[prop];
        } else {
          other[prop] = styles[prop];
        }
      }
      return { allowed, other };
    }
  
    _styleObjectToString(styleObj) {
      return Object.entries(styleObj)
        .map(([prop, value]) => `${prop}:${value}`)
        .join(";");
    }
  
    _generateHiarchyKey(parentKey, index) {
      return parentKey === "" ? `${index}` : `${parentKey}.${index}`;
    }
  
    // Turns the full regular html5 into the restricted CMS-API html
    FullHtmlToLesserHtml(fullHtml) {
      const docRoot = HTMLtoDOM(fullHtml); // Temporary div containing the input HTML
      const esesMapping = {};
      const lesserRoot = document.createElement("div"); // A single root for the lesser HTML
  
      let globalChildIndex = 0;
      Array.from(docRoot.childNodes).forEach((child) => {
        if (child.nodeType === Node.ELEMENT_NODE) {
          const lesserNodes = this._processElement(child, "", `${globalChildIndex}`, esesMapping);
          lesserNodes.forEach((node) => {
            if (node) {
              lesserRoot.appendChild(node);
            }
          });
          globalChildIndex++;
        } else if (child.nodeType === Node.TEXT_NODE && child.textContent.trim().length > 0) {
          // Top-level text content
          const p = document.createElement("p");
          p.textContent = child.textContent.trim();
          lesserRoot.appendChild(p);
          globalChildIndex++;
        }
      });
  
      if (Object.keys(esesMapping).length > 0) {
        const esesMetaP = document.createElement("p");
        esesMetaP.setAttribute("style", "display: none;");
        esesMetaP.textContent = this.esesJsonToMetaString(esesMapping);
        lesserRoot.prepend(esesMetaP);
      }
  
      if (!lesserRoot.getAttribute("style")) {
        lesserRoot.setAttribute("style", "display:block;");
      }
  
      return lesserRoot.outerHTML;
    }
  
    // Recursive helper for FullHtmlToLesserHtml
    _processElement(originalEl, parentHiarchyKey, selfIndex, esesMapping) {
      const originalTagName = originalEl.tagName.toLowerCase();
      const currentHiarchyKey = this._generateHiarchyKey(parentHiarchyKey, selfIndex);
      const esesData = { element: originalTagName };
  
      // --- 1. Handle Attributes & Styles ---
      const attributes = {};
      if (originalTagName === "img") {
        for (const attr of originalEl.attributes) {
          if (!this.allowedImgAttributes.includes(attr.name) && attr.name !== "style") {
            attributes[attr.name] = attr.value;
          }
        }
      } else {
        for (const attr of originalEl.attributes) {
          if (attr.name !== "style") {
            attributes[attr.name] = attr.value;
          }
        }
      }
      if (Object.keys(attributes).length > 0) {
        esesData.attributes = attributes;
      }
  
      const originalStyleText = originalEl.getAttribute("style") || "";
      const allowedPH3StylesInOriginal = this._extractAllowedStyles(originalEl, "p").allowed;
      const allowedDivStylesInOriginal = this._extractAllowedStyles(originalEl, "div").allowed;
  
      const allOriginalStyles = {};
      originalStyleText.split(";").forEach((s) => {
        const parts = s.split(":").map((p) => p.trim());
        if (parts.length === 2 && parts[0] && parts[1]) {
          allOriginalStyles[parts[0]] = parts[1];
        }
      });
  
      const nonAllowedStyles = {};
      for (const prop in allOriginalStyles) {
        if (
          !this.allowedDivStyles.includes(prop) &&
          !this.allowedPH3Styles.includes(prop)
        ) {
          nonAllowedStyles[prop] = allOriginalStyles[prop];
        }
      }
      if (Object.keys(nonAllowedStyles).length > 0) {
        esesData.styles = nonAllowedStyles;
      }
  
      // --- 2. Determine Content Type & Emptiness ---
      let hasChildElements = false;
      let hasSignificantTextContent = false;
      for (const child of originalEl.childNodes) {
        if (child.nodeType === Node.ELEMENT_NODE) {
          hasChildElements = true;
        } else if (child.nodeType === Node.TEXT_NODE && child.textContent.trim().length > 0) {
          hasSignificantTextContent = true;
        }
      }
      const isEmpty = !hasChildElements && !hasSignificantTextContent;
  
      // --- 3. Category 5: NotRepresented or Truly Empty Elements ---
      if (this.elementsMap.notRepresented.includes(originalTagName) || isEmpty) {
        if (!isEmpty) {
          esesData.content = originalEl.outerHTML; // Preserve full original HTML for complex non-represented
        }
        if (Object.keys(esesData).length > 1 || (!isEmpty && this.elementsMap.notRepresented.includes(originalTagName))) {
          esesMapping[currentHiarchyKey] = esesData;
        }
        return []; // Not represented in LesserHTML
      }
  
      // --- 4. Determine Target LesserHTML Tag and apply direct LesserHTML styles/attributes ---
      let lesserElementToBuild;
      let finalLesserTagName;
  
      const isMappedToP = this.elementsMap.text.includes(originalTagName) ||
                          this.elementsMap.emulated.some(([tag]) => tag === originalTagName);
      const isMappedToH3 = this.elementsMap.header.includes(originalTagName);
      const isMappedToDiv = this.elementsMap.container.includes(originalTagName);
  
      // If a non-div element has actual element children, it *must* become a div
      const needsLesserDivWrapper = !isMappedToDiv && (isMappedToP || isMappedToH3) && hasChildElements;
  
      if (originalTagName === "img") {
        finalLesserTagName = "img";
        lesserElementToBuild = document.createElement("img");
        const src = originalEl.getAttribute("src");
        if (src) {
          lesserElementToBuild.setAttribute("src", src);
        }
        const lesserImgStyles = this._styleObjectToString(allowedDivStylesInOriginal); // img can inherit div-like styles
        if (lesserImgStyles) {
          lesserElementToBuild.setAttribute("style", lesserImgStyles);
        }
      } else if (needsLesserDivWrapper) {
        finalLesserTagName = "div";
        lesserElementToBuild = document.createElement("div");
        const divStyles = this._styleObjectToString(allowedDivStylesInOriginal);
        if (divStyles) {
          lesserElementToBuild.setAttribute("style", divStyles);
        } else {
          lesserElementToBuild.setAttribute("style", "display:block;");
        }
      } else if (isMappedToH3) {
        finalLesserTagName = "h3";
        lesserElementToBuild = document.createElement("h3");
        const h3Styles = this._styleObjectToString(allowedPH3StylesInOriginal);
        if (h3Styles) { lesserElementToBuild.setAttribute("style", h3Styles); }
      } else if (isMappedToP) {
        finalLesserTagName = "p";
        lesserElementToBuild = document.createElement("p");
        const pStyles = this._styleObjectToString(allowedPH3StylesInOriginal);
        if (pStyles) { lesserElementToBuild.setAttribute("style", pStyles); }
  
        const emulatedEntry = this.elementsMap.emulated.find(([tag]) => tag === originalTagName);
        if (emulatedEntry) {
          const representationText = emulatedEntry[1](originalEl);
          if (representationText) {
            esesData.content = representationText;
            lesserElementToBuild.textContent = representationText;
          }
        }
      } else if (isMappedToDiv) {
        finalLesserTagName = "div";
        lesserElementToBuild = document.createElement("div");
        const divStyles = this._styleObjectToString(allowedDivStylesInOriginal);
        if (divStyles) {
          lesserElementToBuild.setAttribute("style", divStyles);
        } else {
          lesserElementToBuild.setAttribute("style", "display:block;");
        }
      } else { // Fallback for elements not explicitly mapped but have content
        finalLesserTagName = "div";
        lesserElementToBuild = document.createElement("div");
        const divStyles = this._styleObjectToString(allowedDivStylesInOriginal);
        if (divStyles) {
          lesserElementToBuild.setAttribute("style", divStyles);
        } else {
          lesserElementToBuild.setAttribute("style", "display:block;");
        }
      }
  
      if (Object.keys(esesData).length > 1) { // Store mapping if there's anything beyond just `element`
        esesMapping[currentHiarchyKey] = esesData;
      }
  
      // --- 5. Process Children ---
      let textBuffer = "";
      let childLesserNodeIndex = 0;
  
      for (const child of originalEl.childNodes) {
        if (child.nodeType === Node.TEXT_NODE) {
          if (child.textContent.trim().length > 0) {
            textBuffer += child.textContent;
          }
        } else if (child.nodeType === Node.ELEMENT_NODE) {
          // Flush any accumulated text before processing an element child
          if (textBuffer.trim().length > 0) {
            const textWrapperHiarchyKey = this._generateHiarchyKey(currentHiarchyKey, childLesserNodeIndex++);
            const pOrH3 = document.createElement(isMappedToH3 ? "h3" : "p");
            pOrH3.textContent = textBuffer;
            esesMapping[textWrapperHiarchyKey] = { isWrapper: true };
            lesserElementToBuild.appendChild(pOrH3);
            textBuffer = "";
          }
  
          const convertedChildren = this._processElement(child, currentHiarchyKey, `${childLesserNodeIndex}`, esesMapping);
          convertedChildren.forEach((node) => {
            if (node) {
              lesserElementToBuild.appendChild(node);
              childLesserNodeIndex++;
            }
          });
        }
      }
  
      // Flush any remaining text buffer
      if (textBuffer.trim().length > 0) {
        const textWrapperHiarchyKey = this._generateHiarchyKey(currentHiarchyKey, childLesserNodeIndex++);
        const pOrH3 = document.createElement(isMappedToH3 ? "h3" : "p");
        pOrH3.textContent = textBuffer;
        esesMapping[textWrapperHiarchyKey] = { isWrapper: true };
        lesserElementToBuild.appendChild(pOrH3);
      }
  
      // If an element like <p> had direct text content and no children, ensure it's copied
      if (!lesserElementToBuild.textContent && originalEl.textContent.trim().length > 0 &&
          (finalLesserTagName === 'p' || finalLesserTagName === 'h3') &&
          !hasChildElements && !esesData.content) {
          lesserElementToBuild.textContent = originalEl.textContent.trim();
      }
  
  
      return [lesserElementToBuild]; // Always return an array of the LesserHTML element(s) produced
    }
  
    // Turns the restricted CMS-API html into the full regular html5
    LesserHtmlToFullHtml(lesserHtml) {
      const docRoot = HTMLtoDOM(lesserHtml); // This is a temporary div holding the LesserHTML structure
      let esesMapping = {};
  
      // Find and parse the ESES mapping data
      const esesMetaP = docRoot.querySelector('p[style*="display: none;"]');
      if (esesMetaP && esesMetaP.textContent.startsWith("ESES" + this.esesVersion + ":")) {
        try {
          esesMapping = this.metaStringToEsesJson(esesMetaP.textContent);
          esesMetaP.remove(); // Remove the meta p tag from the LesserHTML DOM
        } catch (e) {
          console.error("Error parsing ESES meta string:", e);
          esesMapping = {};
        }
      }
  
      // Recursive function to restore a single node
      const restoreNode = (lesserNode, parentHiarchyKey, currentLesserHtmlChildIndex) => {
        if (lesserNode.nodeType === Node.TEXT_NODE) {
          return lesserNode; // Text nodes are returned as-is
        }
        if (lesserNode.nodeType !== Node.ELEMENT_NODE) {
          return null; // Ignore non-element nodes that aren't text
        }
  
        const currentHiarchyKey = this._generateHiarchyKey(parentHiarchyKey, currentLesserHtmlChildIndex);
        const meta = esesMapping[currentHiarchyKey];
  
        // --- 1. Handle `isWrapper` first: replace with text content ---
        if (
          (lesserNode.tagName.toLowerCase() === "p" || lesserNode.tagName.toLowerCase() === "h3") &&
          meta &&
          meta.isWrapper
        ) {
          return document.createTextNode(lesserNode.textContent);
        }
  
        // --- 2. Create the new (restored) element ---
        let restoredElement;
        let originalTagName = lesserNode.tagName.toLowerCase(); // Default if no meta.element
  
        if (meta && meta.element) {
          originalTagName = meta.element;
          restoredElement = document.createElement(originalTagName);
        } else {
          restoredElement = document.createElement(originalTagName); // Create with its existing LesserHTML tag
        }
  
        // --- 3. Copy/Apply attributes & styles from LesserHTML + ESES ---
        // Copy attributes from the LESSERHTML node first
        for (const attr of lesserNode.attributes) {
          if (attr.name !== "style") { // Style handled separately
              restoredElement.setAttribute(attr.name, attr.value);
          }
        }
        // Apply original attributes from ESES mapping (will overwrite if same name)
        if (meta && meta.attributes) {
          for (const attr in meta.attributes) {
            restoredElement.setAttribute(attr, meta.attributes[attr]);
          }
        }
  
        // Apply original styles from ESES mapping
        let finalStyleString = lesserNode.getAttribute("style") || "";
        if (meta && meta.styles) {
          const existingStyles = {};
          finalStyleString.split(";").forEach((s) => {
            const parts = s.split(":").map((p) => p.trim());
            if (parts.length === 2 && parts[0] && parts[1]) {
              existingStyles[parts[0]] = parts[1];
            }
          });
          const combinedStyles = { ...existingStyles, ...meta.styles };
          finalStyleString = this._styleObjectToString(combinedStyles);
        }
        if (finalStyleString) {
            restoredElement.setAttribute("style", finalStyleString);
        } else {
            restoredElement.removeAttribute("style");
        }
  
        // --- 4. Restore content if provided in ESES mapping (e.g., for emulated or not-represented elements) ---
        if (meta && meta.content !== undefined) {
          restoredElement.innerHTML = meta.content;
          return restoredElement; // No further children to process recursively if innerHTML is set
        }
  
        // --- 5. Recursively process children ---
        let childLesserNodeIndex = 0;
        // Get a static list of children from the LESSERHTML node to iterate safely
        const childrenInLesserNode = Array.from(lesserNode.childNodes);
  
        for (const childOfLesserNode of childrenInLesserNode) {
          const restoredChild = restoreNode(childOfLesserNode, currentHiarchyKey, childLesserNodeIndex);
  
          if (restoredChild) {
              // Append the restored child to the newly created restoredElement
              restoredElement.appendChild(restoredChild);
              // Only increment if a valid node was successfully appended
              childLesserNodeIndex++;
          }
          // If restoredChild is null, it means it was a 'notRepresented' element
          // that was originally removed, so we just skip it (don't append, don't increment index).
        }
  
        return restoredElement; // Return the fully restored element
      };
  
      // Process top-level children of the temporary div (docRoot)
      const processedNodes = [];
      let topLevelLesserHtmlIndex = 0;
      Array.from(docRoot.childNodes).forEach((child) => {
        const restored = restoreNode(child, "", topLevelLesserHtmlIndex);
        if (restored) {
          processedNodes.push(restored);
          topLevelLesserHtmlIndex++;
        }
      });
  
      // Reconstruct the full HTML string by returning the innerHTML of a temp container
      const tempContainer = document.createElement("div");
      processedNodes.forEach((n) => tempContainer.appendChild(n));
      return tempContainer.innerHTML;
    }
  }
  
  // Test
  window.addEventListener("DOMContentLoaded", (event) => {
    const eses = new ESESApiExtender({});
  
    const html = `
      <body>
          <main style="border: 1px solid red;">
              <h1>Header with <em>emphasis</em> and <span>span</span></h1>
              <figure>
                  <img src="image.jpg" alt="A lovely image">
                  <figcaption style="font-style: italic;">Caption for image</figcaption>
              </figure>
              <p>A simple paragraph with <strong>bold</strong> and <i>italic</i> text.</p>
              <video width="320" height="240" controls autoplay>
                  <source src="video.mp4" type="video/mp4">
                  Your browser does not support the video tag.
              </video>
              <br>
              <hr>
              <script>alert('hello');</script>
              <input type="text" value="some text">
          </main>
          <aside style="background-color: lightgray; padding: 10px;">
              <h6>Side Header</h6>
              <p>Regular text</p>
              <img src="sideimage.png">
              <img src="sideimage2.png" alt="An image">
              <div>
                <p>Nested content</p>
                <span>Another span</span>
              </div>
              <ul>
                <li>Item 1</li>
                <li>Item 2</li>
              </ul>
          </aside>
          <p style="font-size: 16px;">Final paragraph outside main/aside.</p>
      </body>
      `;
  
    console.log("Original HTML:");
    console.log(html);
  
    const lesser = eses.FullHtmlToLesserHtml(html);
  
    console.log("\nLesser HTML:");
    console.log(lesser);
  
    const restored = eses.LesserHtmlToFullHtml(lesser);
  
    console.log("\nRestored HTML:");
    console.log(restored);
  
    // Normalize HTML for comparison (remove extra whitespace, standardize attributes order etc.)
    // This is a minimal normalization. Real-world scenarios might need a full HTML parser for comparison.
    const normalizeHtml = (htmlStr) => {
        const tempDiv = document.createElement('div');
        tempDiv.innerHTML = htmlStr;
        // Recursively strip unwanted attributes/nodes or normalize.
        // For now, let's just use outerHTML and then normalize whitespace.
        const normalized = tempDiv.innerHTML
          .replace(/<!--.*?-->/g, "") // Remove comments
          .replace(/\s+/g, " ") // Collapse multiple whitespaces to single space
          .replace(/>\s+</g, "><") // Remove whitespace between tags
          .trim();
        return normalized;
    };
  
    const normalizedOriginal = normalizeHtml(html);
    const normalizedRestored = normalizeHtml(restored);
  
    // For debug:
    // console.log("Normalized Original:", normalizedOriginal);
    // console.log("Normalized Restored:", normalizedRestored);
  
    if (normalizedOriginal === normalizedRestored) {
      console.log("\nSuccess: Restored HTML (normalized) matches original (normalized).");
    } else {
      console.log("\nFailure: Restored HTML (normalized) does NOT match original (normalized).");
      console.log("Original Length:", normalizedOriginal.length);
      console.log("Restored Length:", normalizedRestored.length);
  
      // Simple diff to help pinpoint differences for debugging
      let diffString = '';
      const minLength = Math.min(normalizedOriginal.length, normalizedRestored.length);
      for (let i = 0; i < minLength; i++) {
          if (normalizedOriginal[i] !== normalizedRestored[i]) {
              diffString += `^(${normalizedOriginal[i] || ' '}/${normalizedRestored[i] || ' '})`;
          } else {
              diffString += normalizedOriginal[i];
          }
      }
      if (normalizedOriginal.length > minLength) {
          diffString += `(...orig: ${normalizedOriginal.substring(minLength)})`;
      } else if (normalizedRestored.length > minLength) {
          diffString += `(...rest: ${normalizedRestored.substring(minLength)})`;
      }
      console.log("\nCharacter-by-character diff (start of divergence):");
      console.log(diffString.substring(0, 500) + (diffString.length > 500 ? '...' : ''));
    }
  
    // --- Additional tests for specific scenarios ---
    console.log("\n--- Specific Scenario Tests ---");
  
    // Test: Empty P tag (should be removed from LesserHTML and only in ESES mapping)
    const emptyPHtml = `<p></p>`;
    const lesserEmptyP = eses.FullHtmlToLesserHtml(emptyPHtml);
    console.log(`\nEmpty <p> tag -> Lesser HTML: "${lesserEmptyP}"`);
    const restoredEmptyP = eses.LesserHtmlToFullHtml(lesserEmptyP);
    console.log(`Empty <p> tag -> Restored HTML: "${restoredEmptyP}"`);
  
    // Test: Div with no styles (should get display:block)
    const divNoStyleHtml = `<div>Hello World</div>`;
    const lesserDivNoStyle = eses.FullHtmlToLesserHtml(divNoStyleHtml);
    console.log(`\nDiv with no style -> Lesser HTML: "${lesserDivNoStyle}"`);
    const restoredDivNoStyle = eses.LesserHtmlToFullHtml(lesserDivNoStyle);
    console.log(`Div with no style -> Restored HTML: "${restoredDivNoStyle}"`);
  
    // Test: Header with direct text and inner element
    const headerWithMixedContent = `<h2>Header start <em>with emphasis</em> and end</h2>`;
    const lesserMixedHeader = eses.FullHtmlToLesserHtml(headerWithMixedContent);
    console.log(`\nMixed content header -> Lesser HTML: "${lesserMixedHeader}"`);
    const restoredMixedHeader = eses.LesserHtmlToFullHtml(lesserMixedHeader);
    console.log(`\nMixed content header -> Restored HTML: "${restoredMixedHeader}"`);
  
    // Test: `ul` element (should become `div` with `li` mapped to `p` and original `ul` tag/attributes in ESES)
    const ulHtml = `<ul><li>Item 1</li><li>Item 2</li></ul>`;
    const lesserUl = eses.FullHtmlToLesserHtml(ulHtml);
    console.log(`\nUL element -> Lesser HTML: "${lesserUl}"`);
    const restoredUl = eses.LesserHtmlToFullHtml(lesserUl);
    console.log(`\nUL element -> Restored HTML: "${restoredUl}"`);
  
    // Test: A self-closing tag that is 'notRepresented' like <br>
    const brHtml = `<p>Before<br>After</p>`;
    const lesserBr = eses.FullHtmlToLesserHtml(brHtml);
    console.log(`\n<br> element -> Lesser HTML: "${lesserBr}"`);
    const restoredBr = eses.LesserHtmlToFullHtml(lesserBr);
    console.log(`\n<br> element -> Restored HTML: "${restoredBr}"`);
  
  });