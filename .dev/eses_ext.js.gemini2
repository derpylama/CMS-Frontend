/*
ESES Extension

  ESES Defines a way to encode arbitrary HTML into the restricted CMS-API format while maintaining readability for non ESES aware clients to the extent possible.

  The extension builds on having a `<p style="display: none;">` tag containing ESES mapping data, this one maps element-hiarchy-keys to the elements extended data.
  This is since the CMS API format only allows:
    HTML Elements:
      - p
      - h3
      - div
      - img (with only property "src")
    
    p/h3 CSS Style Properties:
      - font-size
      - color
      - display
      - font-family
      - font-weight
      - font-style
      - text-decoration
      - text-transform

    div CSS Style Properties:
      - width
      - height
      - display
      - background-color
      - flex-flow
      - align-items
      - justify-content
      - border
      - border-radius
      - margin
      - margin-top
      - margin-bottom
      - margin-left
      - margin-right
      - padding
      - padding-top
      - padding-bottom
      - padding-left
      - padding-right
      - background-image

    And div is the only element who can have child elements, p and h3 must only have text content.

  The goal of ESES is to map additional HTML element types, their properties (except img src), content for non text elements aswell as any CSS properties not supported by the CMS format.
    This means if an element is of a type not supported we can represent it as a div, p or h3 then map that element's hiarchy key to the original element type and its properties.
    Elements properties and css-properties that are supported by the CMS format should be kept inside the html however any non supported properties should be stored in the ESES mapping data.

    The ESES mapping data must be html+ini safe text and is thus stored as base64 incoded JSON. With the prefix "ESES1:" (for v1 of the ESES extension)
      since the mapping element has `display: none` we hint to other clients that this is not meant to be displayed.
      
      The JSON structure is: 
        {
            "<hiarchy-key>": {
                "element": "<original-element-type>",
                "attributes": {
                    "<attribute-name>": "<attribute-value>",
                    ...
                },
                "styles": {
                    "<css-property-name>": "<css-property-value>",
                    ...
                },
                "content": "<non-text-content>",
                "isWrapper": <true|false>
            },
            ...
        }

      But fields `element`, `attributes`, `styles` and `content` are omitted if they are not relevant to that element. `isWrapper` is only present and true if the element was only added because its parent had to be converted to a div to hold children and this wraps the content, this element can thus be replaced with its own text-content.

    HTML elements can be categorized into one of the following five categories:
      1. Headers - h1, h2, h4, h5, h6 - Mapped to `h3`
      2. Text - Al elements that are primarily text-based, ex semantics like `em` or formatters like `b` and `i`. - Mapped to `p`
      3. Containers - Elements semantic or layouting that contain other elements, ex `main` or `span` - Mapped to `div`
      4. Represented - Elements who are not supported but can have thier core properties represented as text for non ESES clients, ex `video` who can be represented as `[Video: <source>]` - Mapped to `p`
      5. NotRepresented - Elements that have no relevant representation outside of ESES, ex `script`, self closing elements or non-content elements are also in this category like `br`, stored fully in ESES.

    Since we want to maintain readability for non ESES clients we try to map elements to the first three categories when possible, otherwise we try to the "represented" category before falling back to "not represented".
      Example `<b>bold text</b>` becomes `<p>bold text</p>` with mapping data saying that this hiarchy key is a `b` element.
      And `<figure><img src="image.jpg"><figcaption>Caption</figcaption></figure>` becomes `<div><img src="image.jpg"><p>Caption</p></div>` with mapping data saying that the hiarchy key of the div is a `figure` element and the hiarchy key of the p is a `figcaption` element.
      But some elements make more sense to be represented with their content, ex `<video><source src="video.mp4"></video>` becomes `<p>[Video: video.mp4]</p>` combining the <source> element into the representation.

    But since the API only supports child elements under `div` elements any children under non-container elements will have thier parent converted into a div.
      Example `<h2>Header <em>with emphasis</em></h2>` becomes `<div><h3>Header </h3><p>with emphasis</p></div>` with mapping data saying that the hiarchy key of the div is an `h2` element and the hiarchy key of the p is an `em` element and the hiarchy key of the h3 has "isWrapper" true meaning the h3 can be reduced to their text-content when back-converting.
      Example `<h2>Header start <em> with emphasis</em> and end</h2>` becomes `<div><h3>Header start </h3><p> with emphasis</p><h3> and end</h3></div>` with mapping data saying that the hiarchy key of the div is an `h2` element, the hiarchy key of the p is an `em` element and both h3 hiarchy keys have "isWrapper" true meaning they can be reduced to their text-content when back-converting.

    When back-converting we use the mapping data to restore the original elements, completely, recursing over and handling "isWrapper" elements by replacing them with their text-content, and restoring attributes, styles and content as needed, aswell as the element type ofcourse.

    When converting we can use recursion and the bellow elementsMap, if an element type is under "header" and has no child elements we map it to `h3`, if its under "text" and has no child elements we map it to `p`, if its under "container" we map it to `div`,
      if it has content and is udner "header" or "text" we handle with the "isWrapper" logic.
    If its under emulated we use the provided function to get its text representation.
    All other elements are mapped to NotRepresented.

    Example WonkyHTML with ESES data:
    <div style="width:100%;height:650px;display:flex;background-color:#d6d6d6;flex-flow:column;justify-content:space-around;padding-bottom:25px;">
        <p style="display: none;">ESES1:...base64-encode-of-json...</p>
        <h3 style="font-size:36px;color:#005500;">Koalor – Allmänt</h3>
        <p style="font-size:18px;color:#003300;">Koalor är små tåliga trädlevande djur från Australien.</p>
        <img style="width:100%;height:250px;height:250;border-radius:10;border-radius:10;display:block;" src="https://upload.wikimedia.org/wikipedia/commons/4/49/Koala_climbing_tree.jpg" alt="Image">
        <div style="width:80%;height:300px;display:flex;background-color:#a3d9a5;flex-flow:row;">
            <h3 style="font-size:28px;color:#006633;">Fakta om Koalor</h3>
            <p style="font-size:16px;color:#666600;">De är kända för att äta eukalyptusblad.</p>
            <p style="font-size:18px;color:#ff6600;">Koalor äter nästan uteslutande eukalyptusblad.</p>
            <img style="width:80%;height:200px;height:200;border-radius:15;border-radius:15;display:block;" src="https://upload.wikimedia.org/wikipedia/commons/e/e9/Koala_eating_eucalyptus_leaf.jpg" alt="Image">
        </div>
        <div style="width:80%;height:250px;display:flex;background-color:#ffe4b5;flex-flow:column;">
            <h3 style="font-size:24px;color:green;">Roliga fakta</h3>
            <p style="font-size:16px;color:#005500;">Koalor sover upp till 20 timmar per dag.</p>
            <p style="font-size:14px;">Koalor har starka klor för att klättra i träd.</p>
            <p style="">Koalor kommunicerar med olika ljud, från snarkningar till skrik.</p>
            <p style="">test</p>
            <img style="width:90%;height:180px;height:180;border-radius:20;border-radius:20;display:block;" src="https://upload.wikimedia.org/wikipedia/commons/0/08/Koala_sleeping_in_tree.jpg" alt="Image">
            <img style="width:70%;height:140px;height:140;border-radius:25;border-radius:25;display:block;" src="https://upload.wikimedia.org/wikipedia/commons/1/14/Koala_close_up.jpg" alt="Image">
        </div>
    </div>
*/

class ESESApiExtender {
    constructor(api) {
        this.api = api;
        this.esesVersion = "1";
        this.esesMeta = {};
        this.nextKey = 0;

        this.cmsSupportedPAndH3Styles = [
            "font-size", "color", "display", "font-family", "font-weight",
            "font-style", "text-decoration", "text-transform"
        ];

        this.cmsSupportedDivStyles = [
            "width", "height", "display", "background-color", "flex-flow",
            "align-items", "justify-content", "border", "border-radius", "margin",
            "margin-top", "margin-bottom", "margin-left", "margin-right", "padding",
            "padding-top", "padding-bottom", "padding-left", "padding-right",
            "background-image"
        ];

        this.elementsMap = {
            "header": [
                "h1", "h2", "h4", "h5", "h6"
            ],
            "text": [
                "p", "span", "em", "strong", "b", "i", "u", "small", "mark", "sub", "sup"
            ],
            "container": [
                "div", "main", "section", "article", "header", "footer", "aside", "nav",
                "figure", "figcaption", "ul", "ol", "li", "blockquote"
            ],
            "emulated": [
                ["video", (el) => {
                    const sourceEl = el.querySelector("source");
                    if (sourceEl && sourceEl.hasAttribute("src")) {
                        return `[Video: ${sourceEl.getAttribute("src")}]`;
                    }
                    return "[Video]";
                }],
                ["audio", (el) => {
                    const sourceEl = el.querySelector("source");
                    if (sourceEl && sourceEl.hasAttribute("src")) {
                        return `[Audio: ${sourceEl.getAttribute("src")}]`;
                    }
                    return "[Audio]";
                }],
            ]
            // All other elements are fallbacked to NotRepresented
        }
    }

    esesJsonToMetaString(jsonobj) {
        const jsonstr = JSON.stringify(jsonobj);
        const base64str = btoa(jsonstr); // Use btoa for browser environments
        return "ESES" + this.esesVersion + ":" + base64str;
    }

    metaStringToEsesJson(metastr) {
        const esesPrefix = "ESES" + this.esesVersion + ":";
        if (!metastr.startsWith(esesPrefix)) {
            throw new Error("Invalid ESES meta string");
        }

        const base64str = metastr.slice(esesPrefix.length);
        const jsonstr = atob(base64str); // Use atob for browser environments
        return JSON.parse(jsonstr);
    }

    // Helper to check if an element has child elements other than text nodes
    hasActualChildElements(element) {
        return Array.from(element.children).some(
            (child) => child.nodeType === Node.ELEMENT_NODE
        );
    }

    // Helper to get supported styles for an element
    getSupportedStyles(element, isDiv = false) {
        const supportedStyles = {};
        const elementStyles = element.style;
        const cmsSupported = isDiv ?
            this.cmsSupportedDivStyles :
            this.cmsSupportedPAndH3Styles;

        for (const prop of cmsSupported) {
            if (elementStyles[prop]) {
                supportedStyles[prop] = elementStyles[prop];
            }
        }
        return supportedStyles;
    }

    // Helper to get unsupported styles for an element
    getUnsupportedStyles(element, isDiv = false) {
        const unsupportedStyles = {};
        const elementStyles = element.style;
        const cmsSupported = isDiv ?
            this.cmsSupportedDivStyles :
            this.cmsSupportedPAndH3Styles;

        for (const prop of Array.from(elementStyles)) {
            if (!cmsSupported.includes(prop)) {
                unsupportedStyles[prop] = elementStyles[prop];
            }
        }
        return unsupportedStyles;
    }

    // Helper to get attributes
    getAttributes(element, supportedImgSrc = true) {
        const attributes = {};
        for (const attr of element.attributes) {
            if (supportedImgSrc && element.tagName.toLowerCase() === "img" &&
                attr.name === "src") {
                continue; // Skip src for img as it's directly supported
            }
            attributes[attr.name] = attr.value;
        }
        return attributes;
    }


    ToFullHtml(html) {
        this.esesMeta = {};
        this.nextKey = 0;
        const parser = new DOMParser();
        const doc = parser.parseFromString(html, "text/html");
        // We handle the root elements directly since `doc.body` might not exist or be the direct target.
        const fragment = document.createDocumentFragment();

        Array.from(doc.documentElement.children).forEach(child => {
            if (child.tagName.toLowerCase() === 'body') {
                Array.from(child.children).forEach(bodyChild => {
                    const processedNode = this.processNodeToLesserHtml(bodyChild);
                    if (processedNode) {
                        fragment.appendChild(processedNode);
                    }
                });
            } else {
                const processedNode = this.processNodeToLesserHtml(child);
                if (processedNode) {
                    fragment.appendChild(processedNode);
                }
            }
        });

        const tempDiv = document.createElement('div');
        tempDiv.appendChild(fragment);

        if (Object.keys(this.esesMeta).length > 0) {
            const esesMetaP = document.createElement("p");
            esesMetaP.style.display = "none";
            esesMetaP.textContent = this.esesJsonToMetaString(this.esesMeta);
            tempDiv.prepend(esesMetaP);
        }

        return tempDiv.innerHTML;
    }

    processNodeToLesserHtml(node, parentOriginalTag = null) {
        if (node.nodeType === Node.TEXT_NODE) {
            if (node.textContent.trim() === "") {
                return null; // Don't create empty text nodes
            }
            const p = document.createElement("p");
            p.textContent = node.textContent;

            // If a text node's direct parent was not a container and had children,
            // this text node also acts as a wrapper.
            if (parentOriginalTag &&
                (this.elementsMap.header.includes(parentOriginalTag) ||
                    this.elementsMap.text.includes(parentOriginalTag))) {
                const key = this.nextKey++;
                this.esesMeta[key] = {
                    isWrapper: true
                };
                p.setAttribute("data-eses-key", key);
            }

            return p;
        }

        if (node.nodeType !== Node.ELEMENT_NODE) {
            return null;
        }

        const originalTagName = node.tagName.toLowerCase();
        let esesEntry = {
            element: originalTagName
        };
        const key = this.nextKey++;
        node.setAttribute("data-eses-key", key);


        let mappedElement = null;
        let isDiv = false;
        let hasChildren = this.hasActualChildElements(node);

        const attributes = this.getAttributes(node, false); // Get all attributes for meta
        if (Object.keys(attributes).length > 0) {
            esesEntry.attributes = attributes;
        }

        const unsupportedStyles = this.getUnsupportedStyles(node, false);
        if (Object.keys(unsupportedStyles).length > 0) {
            esesEntry.styles = unsupportedStyles;
        }

        // Handle specific img case first
        if (originalTagName === "img") {
            mappedElement = document.createElement("img");
            if (node.hasAttribute("src")) {
                mappedElement.setAttribute("src", node.getAttribute("src"));
            }
            const supportedStyles = this.getSupportedStyles(node, true); // img uses div styles for now
            Object.assign(mappedElement.style, supportedStyles);
            this.esesMeta[key] = esesEntry;
            return mappedElement;
        }

        // Handle emulated elements
        const emulatedMapping = this.elementsMap.emulated.find(
            ([tag]) => tag === originalTagName
        );
        if (emulatedMapping) {
            const textRepresentation = emulatedMapping[1](node);
            mappedElement = document.createElement("p");
            mappedElement.textContent = textRepresentation;
            this.esesMeta[key] = esesEntry;
            return mappedElement;
        }

        // Determine mapped element type based on content and category
        if (this.elementsMap.container.includes(originalTagName) || hasChildren) {
            mappedElement = document.createElement("div");
            isDiv = true;
        } else if (this.elementsMap.header.includes(originalTagName)) {
            mappedElement = document.createElement("h3");
        } else if (this.elementsMap.text.includes(originalTagName)) {
            mappedElement = document.createElement("p");
        } else {
            // NotRepresented category
            // If it has children and is NotRepresented, convert to a div to hold children
            if (hasChildren) {
                mappedElement = document.createElement("div");
                isDiv = true;
            } else if (node.textContent.trim() !== "") {
                mappedElement = document.createElement("p");
                esesEntry.content = node.textContent; // Store original content in meta
            } else {
                // Self-closing or empty not-represented element
                this.esesMeta[key] = esesEntry;
                return null; // Return null to not render in lesser HTML, fully in meta
            }
        }

        // Apply supported styles to the mapped element
        const supportedStyles = this.getSupportedStyles(node, isDiv);
        Object.assign(mappedElement.style, supportedStyles);

        // Append children recursively
        if (mappedElement.tagName.toLowerCase() === "div" || hasChildren) {
            // If the original element was not a div but needs to become one to hold children,
            // then mark the parent as a div and process its children
            Array.from(node.childNodes).forEach(child => {
                const processedChild = this.processNodeToLesserHtml(
                    child,
                    originalTagName
                );
                if (processedChild) {
                    mappedElement.appendChild(processedChild);
                }
            });
        } else if (node.textContent.trim() !== "") {
            // For elements mapped to p or h3 that only contain text
            mappedElement.textContent = node.textContent;
        }


        // Store ESES metadata
        if (Object.keys(esesEntry).length > 1) { // Check if there's more than just the original element tag
            this.esesMeta[key] = esesEntry;
        }

        return mappedElement;
    }


    FromFullHtml(lesserhtml) {
        const parser = new DOMParser();
        const doc = parser.parseFromString(lesserhtml, "text/html");

        let esesMetaElement = null;
        let rootElements = [];

        Array.from(doc.documentElement.children).forEach(child => {
            if (child.tagName.toLowerCase() === 'body') {
                rootElements = Array.from(child.children);
            } else {
                rootElements.push(child);
            }
        });

        // Find and process the ESES metadata element
        for (let i = 0; i < rootElements.length; i++) {
            const child = rootElements[i];
            if (child.tagName.toLowerCase() === "p" && child.style.display === "none" &&
                child.textContent.startsWith("ESES" + this.esesVersion + ":")) {
                esesMetaElement = child;
                this.esesMeta = this.metaStringToEsesJson(child.textContent);
                // Remove the meta element from the list to be processed as content
                rootElements.splice(i, 1);
                break;
            }
        }

        const fragment = document.createDocumentFragment();

        rootElements.forEach(node => {
            const restoredNode = this.restoreNodeFromLesserHtml(node);
            if (restoredNode) {
                fragment.appendChild(restoredNode);
            }
        });

        // Create a temporary div to get the innerHTML of the fragment
        const tempDiv = document.createElement('div');
        tempDiv.appendChild(fragment);

        // If the original HTML had a body tag, wrap the content in a body tag again.
        // This is a heuristic and might need refinement depending on expected input.
        if (lesserhtml.includes('<body')) {
            return `<body>${tempDiv.innerHTML}</body>`;
        }

        return tempDiv.innerHTML;
    }

    restoreNodeFromLesserHtml(node) {
        if (node.nodeType === Node.TEXT_NODE) {
            return document.createTextNode(node.textContent);
        }

        if (node.nodeType !== Node.ELEMENT_NODE) {
            return null;
        }

        const key = node.getAttribute("data-eses-key");
        const esesData = this.esesMeta[key];

        let originalElement = null;

        if (esesData && esesData.isWrapper) {
            // If it's a wrapper, return its text content directly
            return document.createTextNode(node.textContent);
        }

        let originalTagName = node.tagName.toLowerCase();
        if (esesData && esesData.element) {
            originalTagName = esesData.element;
        }

        originalElement = document.createElement(originalTagName);

        // Restore attributes
        if (esesData && esesData.attributes) {
            for (const attrName in esesData.attributes) {
                originalElement.setAttribute(attrName, esesData.attributes[attrName]);
            }
        } else if (originalTagName === "img" && node.hasAttribute("src")) {
            // img src is directly supported and not stored in esesData.attributes
            originalElement.setAttribute("src", node.getAttribute("src"));
        }

        // Restore styles
        if (esesData && esesData.styles) {
            for (const styleProp in esesData.styles) {
                originalElement.style[styleProp] = esesData.styles[styleProp];
            }
        }
        // Always copy directly supported styles
        for (const styleProp of node.style) {
            originalElement.style[styleProp] = node.style[styleProp];
        }

        // Restore content
        if (esesData && esesData.content) {
            originalElement.textContent = esesData.content;
        } else {
            // Recursively restore children
            Array.from(node.childNodes).forEach(child => {
                const restoredChild = this.restoreNodeFromLesserHtml(child);
                if (restoredChild) {
                    originalElement.appendChild(restoredChild);
                }
            });
        }

        return originalElement;
    }
}

// Test
window.addEventListener('DOMContentLoaded', (event) => {
    const eses = new ESESApiExtender({});

    const html = `
    <body>
        <main style="background-color: lightblue; padding: 10px;">
            <h2>Header start <em> with emphasis</em> and end</h2>
            <figure style="border: 1px solid black;">
                <img src="image.jpg" alt="A lovely image">
                <figcaption style="font-style: italic;">Caption</figcaption>
            </figure>
            <video width="320" height="240" controls>
                <source src="video.mp4" type="video/mp4">
                Your browser does not support the video tag.
            </video>
            <p>This is a <b>bold</b> and <i>italic</i> text with <span style="color:red;">red span</span>.</p>
        </main>
        <aside style="float: right;">
            <h6>Side Header</h6>
            <p>Regular text</p>
            <img src="sideimage.png">
            <img src="sideimage2.png" alt="An image">
        </aside>
        <script>alert('malicious code');</script>
        <br>
    </body>
    `;

    const lesser = eses.ToFullHtml(html);

    console.log("Original HTML:");
    console.log(html);
    console.log("\nLesser HTML:");
    console.log(lesser);

    const restored = eses.FromFullHtml(lesser);

    console.log("\nRestored HTML:");
    console.log(restored);

    // For comparison, we need to normalize whitespace and remove the eses-key
    const normalizeHtml = (htmlString) => {
        const tempDiv = document.createElement('div');
        tempDiv.innerHTML = htmlString;
        Array.from(tempDiv.querySelectorAll('[data-eses-key]')).forEach(el => {
            el.removeAttribute('data-eses-key');
        });
        // Remove style attribute if empty
        Array.from(tempDiv.querySelectorAll('[style]')).forEach(el => {
            if (el.getAttribute('style') === '') {
                el.removeAttribute('style');
            }
        });
        return tempDiv.innerHTML.replace(/\s+/g, ' ').trim();
    };

    const normalizedOriginal = normalizeHtml(html);
    const normalizedRestored = normalizeHtml(restored);

    if (normalizedOriginal === normalizedRestored) {
        console.log("\nSuccess: Restored HTML matches original (normalized)");
    } else {
        console.log("\nFailure: Restored HTML does not match original (normalized)");
        // console.log("Normalized Original:", normalizedOriginal);
        // console.log("Normalized Restored:", normalizedRestored);
    }
});